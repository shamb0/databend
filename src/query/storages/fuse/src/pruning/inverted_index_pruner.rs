// Copyright 2021 Datafuse Labs
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

use std::sync::Arc;

use databend_common_catalog::plan::InvertedIndexInfo;
use databend_common_catalog::plan::PushDownInfo;
use databend_common_exception::Result;
use databend_common_expression::types::F32;
use opendal::Operator;

use crate::io::read::InvertedIndexReader;
use crate::io::TableMetaLocationGenerator;

// Each block file has a corresponding index file,
// the data in the index file is generated by tantivy.
// Index searcher return matched docIds and scores for query text.
// If no docId is matched, the corresponding block can be pruned.
//
// ┌────────┐     ┌────────┐   ┌────────┐     ┌────────┐
// │ Index1 │ ... │ IndexM │   │ IndexN │ ... │ IndexZ │
// └────────┘     └────────┘   └────────┘     └────────┘
//     |              |            |              |
//     |              |            |              |
// ┌────────┐     ┌────────┐   ┌────────┐     ┌────────┐
// │ Block1 │ ... │ BlockM │   │ BlockN │ ... │ BlockZ │
// └────────┘     └────────┘   └────────┘     └────────┘
//  \                     /     \                     /
//   \          _________/       \          _________/
//    \        /                  \        /
//     Segment1           ...      SegmentN
//
pub struct InvertedIndexPruner {
    dal: Operator,
    inverted_index_info: InvertedIndexInfo,
}

impl InvertedIndexPruner {
    pub fn try_create(
        dal: Operator,
        push_down: &Option<PushDownInfo>,
    ) -> Result<Option<Arc<InvertedIndexPruner>>> {
        let inverted_index_info = push_down.as_ref().and_then(|p| p.inverted_index.as_ref());
        if let Some(inverted_index_info) = inverted_index_info {
            return Ok(Some(Arc::new(InvertedIndexPruner {
                dal,
                inverted_index_info: inverted_index_info.clone(),
            })));
        }
        Ok(None)
    }

    #[async_backtrace::framed]
    pub async fn should_keep(
        &self,
        block_loc: &str,
        row_count: u64,
    ) -> Result<Option<Vec<(usize, F32)>>> {
        let index_loc = TableMetaLocationGenerator::gen_inverted_index_location_from_block_location(
            block_loc,
            &self.inverted_index_info.index_name,
            &self.inverted_index_info.index_version,
        );

        let inverted_index_reader = InvertedIndexReader::try_create(
            self.dal.clone(),
            &self.inverted_index_info.index_schema,
            &self.inverted_index_info.query_fields,
            &self.inverted_index_info.index_options,
            &index_loc,
        )
        .await?;

        let matched_rows =
            inverted_index_reader.do_filter(&self.inverted_index_info.query_text, row_count)?;

        Ok(matched_rows)
    }
}
